========================================
JPA N+1 문제와 Fetch Join (패치 조인) 완벽 가이드
========================================

JPA(및 Spring Data JPA)를 사용할 때 발생하는 가장 대표적인 성능 문제인 'N+1 문제'와 이를 해결하는 'Fetch Join'에 대해 설명합니다.

---

1. N+1 문제란 무엇인가요?

N+1 문제는 "1번의 쿼리로 N개의 데이터를 가져왔는데, 이 N개의 데이터가 각각 연관된 데이터를 가지고 있어서, 이 연관 데이터를 조회하기 위해 N번의 추가 쿼리가 발생하는 상황"을 말합니다.

결과적으로, 총 1 + N 번의 쿼리가 실행되어 데이터베이스에 심각한 부하를 줍니다.

[ N+1 문제가 발생하는 시나리오 (예시) ]

사용자(UserM)가 여러 개의 운동 기록(ExerciseHistory)을 가지고 있는 @OneToMany 관계를 가정해 보겠습니다. (FetchType.LAZY - 지연 로딩)

1.  Service에서 1번의 쿼리 실행 (1)
    * List<UserM> users = userMRepository.findAll();
    * JPA가 SELECT * FROM user_m; 쿼리를 실행합니다. (쿼리 1번 발생)
    * 이때 users 리스트에 10명(N=10)의 사용자가 조회되었다고 가정합니다.
    * (중요) FetchType.LAZY이므로, exerciseHistory 필드는 아직 DB에서 가져오지 않은 '가짜 객체(프록시)' 상태입니다.

2.  반복문에서 N번의 추가 쿼리 발생 (N)
    * Service나 DTO 변환 과정에서 이 users 목록을 반복문으로 순회합니다.

    for (UserM user : users) {
        // user의 '운동 기록'에 실제로 접근하는 순간 (LAZY 로딩 발생)
        int count = user.getExerciseHistory().size(); // <-- 이 시점에 추가 쿼리 발생
    }

    * JPA는 첫 번째 user의 exerciseHistory를 가져오기 위해 SELECT * FROM exercise_history WHERE user_m_id = 1; (추가 쿼리 1)
    * 두 번째 user의 exerciseHistory를 가져오기 위해 SELECT * FROM exercise_history WHERE user_m_id = 2; (추가 쿼리 2)
    * ...
    * 열 번째 user의 exerciseHistory를 가져오기 위해 SELECT * FROM exercise_history WHERE user_m_id = 10; (추가 쿼리 10)

3.  결과
    * 총 10명의 사용자를 조회하기 위해, 1 (UserM) + 10 (ExerciseHistory) = 11번의 쿼리가 실행됩니다.
    * 만약 사용자가 1000명이면 1001번의 쿼리가 실행되며, 애플리케이션 서버와 DB는 순식간에 다운될 수 있습니다.

---

2. Fetch Join (패치 조인) 이란?

Fetch Join은 JPQL(JPA가 사용하는 쿼리 언어)의 기능 중 하나로, N+1 문제를 해결하는 가장 보편적이고 강력한 방법입니다.

* 핵심 기능: 특정 Entity를 조회할 때, @ManyToOne 또는 @OneToMany로 연관된 Entity까지 단 한 번의 SQL JOIN으로 모두 조회하여 영속성 컨텍스트에 로드합니다.
* 동작 방식: 지연 로딩(LAZY)으로 설정된 필드라도, Fetch Join을 사용하면 JPA가 즉시 로딩(EAGER)처럼 데이터를 미리 다 채워서 객체를 반환합니다.

[ Fetch Join 사용 방법 (Repository) ]

JpaRepository 인터페이스에 @Query 어노테이션을 사용하여 JPQL을 직접 작성합니다.

기본 문법: SELECT [별칭] FROM [Entity] [별칭] JOIN FETCH [연관 필드명]

예시 1: findById에서 N+1 해결 (UserM + AvailableSports + SportType)

사용자님의 DTO 변환 코드(availableSports.getSportType().getSportNm())에서 발생하는 2차 N+1 문제까지 한 번에 해결하는 쿼리입니다.

// UserMRepository.java
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserMRepository extends JpaRepository<UserM, String> {

    // UserM을 조회할 때,
    // 1. availableSports를 즉시 가져오고 (JOIN FETCH)
    // 2. 그 availableSports에 연결된 sportType까지 즉시 가져온다.
    @Query("SELECT u FROM UserM u " +
           "LEFT JOIN FETCH u.availableSports avs " +
           "LEFT JOIN FETCH avs.sportType st " +
           "WHERE u.id = :id")
    Optional<UserM> findUserByIdWithDetails(@Param("id") String id);
}

---

3. Fetch Join 장점과 단점 (주의사항)

[ 장점 ]

* N+1 문제 해결: SQL 쿼리 수를 획기적으로 줄여주므로 성능 최적화에 가장 효과적입니다.
* 코드 수정 최소화: Service나 Controller의 로직 수정 없이, Repository 계층의 쿼리 수정만으로 성능 개선이 가능합니다. (JPA의 객체지향성을 유지)

[ 단점 및 주의사항 ]

* 페이징(Paging) 불가 (치명적):
    @OneToMany 관계(컬렉션)를 Fetch Join하면, Spring Data JPA의 Pageable 기능을 함께 사용할 수 없습니다.
    이유: 1:N 조인을 하면 1개의 UserM이 N개의 AvailableSports만큼 뻥튀기(중복)되어 조회됩니다. (예: User 1명, Sports 5개면 5줄 조회됨) DB는 이 5줄을 기준으로 페이징하지만, JPA는 1명의 User로 인식하여 데이터가 맞지 않아 메모리에서 처리하려다 경고가 발생합니다.
    해결책: 1. default_batch_fetch_size 옵션 사용 (N+1을 허용하되, In 쿼리로 최적화), 2. @ManyToOne 관계만 Fetch Join, 3. DTO로 직접 조회(조인 최적화).

* 불필요한 데이터 조회:
    Fetch Join은 연관된 Entity의 모든 필드를 가져옵니다. 당장 필요하지 않은 데이터까지 조회하여 쿼리가 무거워지고 네트워크 트래픽을 차지할 수 있습니다.

* 별칭(Alias) 사용 불가:
    JOIN FETCH로 가져온 연관 Entity(예: avs, st)에는 JPQL의 WHERE 절이나 ORDER BY 절에서 별칭을 사용할 수 없습니다. (JPA 표준 스펙)
    (예: WHERE st.name = '농구' 같은 조건문 사용 불가)

* 여러 개의 @OneToMany 조인 시 주의:
    2개 이상의 @OneToMany 관계를 Fetch Join하면 (예: availableSports와 exerciseHistory를 동시에) 카테시안 곱(Cartesian Product)이 발생하여 데이터가 의도한 것보다 훨씬 많이 뻥튀기될 수 있습니다. 주의해서 사용해야 합니다.