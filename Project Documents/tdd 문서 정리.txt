================================================================================
[Spring Boot TDD 완벽 가이드]
작성자: Jusung Kang
프로젝트: GPSProject (Backend)
작성일: 2025-11-17
================================================================================

목차
1. Repository Layer 테스트 (UserMRepositoryTest)
2. Service Layer 테스트 (UserMServiceTest)
3. Controller Layer 테스트 (UserMApiControllerTest)

--------------------------------------------------------------------------------
1. Repository Layer 테스트
--------------------------------------------------------------------------------
* 파일명: UserMRepositoryTest.java
* 사용 어노테이션: @DataJpaTest
* 목적: 
  - 실제 데이터베이스(또는 H2 인메모리 DB)와 잘 연결되는지 확인합니다.
  - Entity 객체가 테이블과 잘 매핑되는지, 쿼리(SQL)가 정상적으로 실행되는지 검증합니다.
  - Service나 Controller 없이 "DB 접근 로직"만 독립적으로 테스트합니다.

[코드 설명]
*/
package com.jskang.backend.userM;

import com.jskang.backend.domain.UserM;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
// 실제 DB(MySQL 등)를 쓰려면 아래 줄을 사용. H2(가짜DB)를 쓰려면 주석 처리하거나 삭제.
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) 
class UserMRepositoryTest {

    @Autowired
    private UserMRepository userMRepository;

    /*
     * [함수: saveAndFind]
     * 역할: UserM 엔티티를 저장하고, 저장된 값이 제대로 반환되는지 확인합니다.
     * 검증 포인트:
     * 1. save() 호출 시 ID(Primary Key)가 자동으로 생성되는가? (isNotNull)
     * 2. 저장한 이메일과 핸드폰 번호가 DB에 잘 들어갔는가?
     */
    @Test
    void saveAndFind(){
        // given (준비)
        UserM userM = UserM.builder()
                .email("aaaa@gmail.com")
                .phoneNumber("01011112222")
                .build();

        // when (실행)
        UserM savedUserM = userMRepository.save(userM);

        // then (검증)
        assertThat(savedUserM.getId()).isNotNull();
        assertThat(savedUserM.getEmail()).isEqualTo("aaaa@gmail.com");
        assertThat(savedUserM.getPhoneNumber()).isEqualTo("01011112222");
    }
}


--------------------------------------------------------------------------------
2. Service Layer 테스트
--------------------------------------------------------------------------------
* 파일명: UserMServiceTest.java
* 사용 어노테이션: @ExtendWith(MockitoExtension.class)
* 목적:
  - 비즈니스 로직(회원가입 처리, 데이터 가공, 예외 처리 등)을 검증합니다.
  - DB 연결 없이 순수 자바 코드로 로직만 테스트하므로 속도가 매우 빠릅니다.
  - Repository는 가짜 객체(Mock)를 사용하여 "DB는 무조건 잘 동작한다"고 가정합니다.

[코드 설명]
*/
package com.jskang.backend.userM;

import com.jskang.backend.domain.UserM;
import com.jskang.backend.userM.dto.SaveUserMRequestDto;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.List;
import java.util.Optional;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
class UserMServiceTest {

    @Mock // 가짜 Repository (실제 DB 안감)
    private UserMRepository userMRepository;

    @InjectMocks // 가짜 Repository를 주입받을 진짜 Service
    private UserMService userMService;

    /*
     * [함수: createUserM]
     * 역할: DTO를 받아서 엔티티로 변환 후 Repository에 저장을 요청하는 로직 검증
     * 검증 포인트: Repository의 save() 메서드가 호출되었는가? 반환값이 정확한가?
     */
    @Test
    @DisplayName("회원 생성 테스트")
    void createUserM() {
        // given
        SaveUserMRequestDto requestDto = new SaveUserMRequestDto(); 
        requestDto.setEmail("test@example.com");
        requestDto.setPhoneNumber("01012345678");

        UserM savedUser = UserM.builder().id(1L).email("test@example.com").phoneNumber("01012345678").build();
        given(userMRepository.save(any(UserM.class))).willReturn(savedUser); // 가짜 행동 정의

        // when
        UserM result = userMService.createUserM(requestDto);

        // then
        assertThat(result.getId()).isEqualTo(1L);
        verify(userMRepository).save(any(UserM.class)); // save가 호출되었는지 감시
    }

    /*
     * [함수: updateUserM]
     * 역할: 회원 정보를 수정하는 비즈니스 로직 검증
     * 검증 포인트: ID로 유저를 찾아서(findById), 값을 변경(Setter)했을 때 변경된 값이 반영되는가?
     */
    @Test
    @DisplayName("회원 수정 성공 테스트")
    void updateUserM() {
        // given
        Long userId = 1L;
        SaveUserMRequestDto updateDto = new SaveUserMRequestDto();
        updateDto.setEmail("update@example.com");
        updateDto.setPhoneNumber("01099998888");

        UserM existingUser = UserM.builder().id(userId).email("old@example.com").phoneNumber("01000000000").build();
        given(userMRepository.findById(userId)).willReturn(Optional.of(existingUser));

        // when
        UserM updatedUser = userMService.updateUserM(userId, updateDto);

        // then
        assertThat(updatedUser.getEmail()).isEqualTo("update@example.com");
    }
}


--------------------------------------------------------------------------------
3. Controller Layer 테스트
--------------------------------------------------------------------------------
* 파일명: UserMApiControllerTest.java
* 사용 어노테이션: @WebMvcTest
* 목적:
  - 클라이언트(프론트엔드)가 보내는 HTTP 요청(URL, Body, Parameter)을 잘 받는지 확인합니다.
  - 결과값(JSON)이 약속된 형식대로 나가는지, 상태 코드(200 OK, 404 Not Found 등)가 맞는지 검증합니다.
  - Service는 가짜(Mock)로 대체하여 로직 수행 없이 "요청/응답" 흐름만 테스트합니다.

[코드 설명]
*/
package com.jskang.backend.userM;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jskang.backend.domain.UserM;
import com.jskang.backend.userM.dto.SaveUserMRequestDto;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.bean.override.mockito.MockitoBean; 
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import java.util.List;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(UserMApiController.class)
class UserMApiControllerTest {

    @Autowired
    private MockMvc mockMvc; // 브라우저 없이 HTTP 요청을 날려주는 객체

    @MockitoBean // Service를 가짜로 등록 (Spring Boot 3.4 이상)
    private UserMService userMService;

    @Autowired
    private ObjectMapper objectMapper; // 자바 객체 <-> JSON 변환기

    /*
     * [함수: createUser]
     * 역할: POST /api/users 요청을 테스트
     * 검증 포인트:
     * 1. JSON 데이터를 Body에 담아 보냈을 때 201(Created) 응답이 오는가?
     * 2. 응답 JSON에 내가 보낸 데이터(email 등)가 포함되어 있는가?
     */
    @Test
    @DisplayName("유저 생성(POST) 테스트")
    void createUser() throws Exception {
        // given
        SaveUserMRequestDto requestDto = new SaveUserMRequestDto();
        requestDto.setEmail("test@example.com");
        requestDto.setPhoneNumber("01012345678");

        UserM createdUser = UserM.builder().id(1L).email("test@example.com").build();
        given(userMService.createUserM(any(SaveUserMRequestDto.class))).willReturn(createdUser);

        // when & then
        mockMvc.perform(post("/api/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.email").value("test@example.com"));
    }

    /*
     * [함수: handleIllegalArgumentException]
     * 역할: 예외 발생 시 처리가 잘 되는지 테스트
     * 검증 포인트: 존재하지 않는 ID로 조회 시 404 Not Found 상태코드와 에러 메시지가 반환되는가?
     */
    @Test
    @DisplayName("예외 처리 테스트")
    void handleIllegalArgumentException() throws Exception {
        Long wrongId = 999L;
        given(userMService.findById(wrongId)).willThrow(new IllegalArgumentException("User not found"));

        mockMvc.perform(get("/api/users/{id}", wrongId))
                .andExpect(status().isNotFound())
                .andExpect(content().string("User not found"));
    }
}

================================================================================
어노테이션, 함수 정리
================================================================================
================================================================================
[Spring Boot TDD 핵심 함수 및 어노테이션 정리 사전]
작성자: Jusung Kang
프로젝트: GPSProject (Backend)
================================================================================

[목차]
1. 공통 (JUnit5, AssertJ) - 모든 테스트에서 사용
2. Repository 테스트용 (@DataJpaTest)
3. Service 테스트용 (Mockito)
4. Controller 테스트용 (WebMvcTest, MockMvc)

================================================================================
1. 공통 (JUnit5 & AssertJ)
   : 테스트의 기본 골격을 잡고, 결과를 검증하는 도구들
================================================================================

1) @Test (org.junit.jupiter.api.Test)
   - 역할: 이 함수가 "테스트 케이스"임을 알립니다.
   - 이유: 이 어노테이션이 붙어야 실행 버튼(Run)이 생기고 테스트가 수행됩니다.

2) @DisplayName("설명")
   - 역할: 테스트 이름을 한글이나 문장으로 예쁘게 보여줍니다.
   - 이유: 함수명(saveAndFind)만 보면 무슨 테스트인지 한눈에 알기 어렵기 때문입니다.

3) assertThat(실제값) (org.assertj.core.api.Assertions)
   - 역할: 검증(Assertion)을 시작하는 시작점입니다.
   - 이유: "assertThat(A).isEqualTo(B)" 처럼 문장처럼 읽혀서 가독성이 좋습니다.

4) .isEqualTo(기대값) / .isNotNull()
   - 역할: assertThat 뒤에 붙어서 구체적인 조건을 검사합니다.
     > .isEqualTo(A): 실제값이 A와 같은지 확인
     > .isNotNull(): 객체가 null이 아닌지 확인 (ID 생성 여부 등)

5) assertThatThrownBy(() -> 실행코드)
   - 역할: 예외(에러)가 발생하는지 테스트합니다.
   - 이유: "없는 유저를 조회하면 에러가 나야 한다" 같은 실패 케이스를 검증하기 위함입니다.


================================================================================
2. Repository 테스트 (JPA, DB 연결)
   : 실제/가짜 DB에 쿼리를 날려보는 함수들
================================================================================

1) @DataJpaTest
   - 역할: JPA 관련 설정(Repository, Entity, EntityManager)만 가볍게 로드합니다.
   - 이유: 전체 스프링을 띄우면 느리니까, DB 관련만 띄워서 빠르게 테스트하려고 씁니다.

2) @AutoConfigureTestDatabase(replace = Replace.NONE)
   - 역할: 스프링이 제공하는 가짜 DB(H2)로 바꿔치기 하지 말고, 설정된 DB를 쓰라고 지시합니다.
   - 이유: "나는 H2 말고 내 진짜 MySQL(혹은 설정된 DB) 연결이 잘 되는지 보고 싶어" 할 때 씁니다.

3) repository.save(엔티티)
   - 역할: 엔티티를 DB에 insert(저장) 또는 update(수정) 합니다.
   - 리턴: ID가 생성된 저장된 엔티티를 돌려줍니다.

4) repository.findById(ID)
   - 역할: PK(Primary Key)로 데이터를 조회합니다.
   - 리턴: Optional<Entity> 타입을 반환합니다. (값이 있을 수도, 없을 수도 있어서)


================================================================================
3. Service 테스트 (Mockito - 가짜 객체 활용)
   : DB 없이 순수 자바 로직만 검증하는 함수들
================================================================================

1) @ExtendWith(MockitoExtension.class)
   - 역할: JUnit5에게 "Mockito(가짜 객체 라이브러리) 기능을 쓸 거야"라고 알려줍니다.
   - 이유: 이게 있어야 @Mock 어노테이션이 작동합니다.

2) @Mock
   - 역할: 껍데기만 있는 가짜 객체를 만듭니다. (예: 가짜 Repository)
   - 이유: 실제 DB에 연결하지 않고, Service가 Repository를 호출하는 척만 하기 위함입니다.

3) @InjectMocks
   - 역할: @Mock으로 만든 가짜들을, 테스트할 진짜 객체(Service)에 주입(조립)해줍니다.
   - 이유: Service는 Repository가 필요하니까, 가짜 Repository를 끼워주는 겁니다.

4) given(가짜함수호출).willReturn(돌려줄값)
   - 역할: 시나리오를 짭니다. "가짜 Repository야, findById(1)이 호출되면 이 유저 객체를 리턴해줘"
   - 이유: 가짜 객체는 멍청해서 시키지 않으면 null만 줍니다. 행동을 학습시키는 과정입니다.

5) any(클래스.class)
   - 역할: "어떤 객체든 상관없음"이라는 뜻입니다.
   - 예: given(repo.save(any(UserM.class))) -> "어떤 유저 객체가 save에 들어오든 간에..."

6) verify(가짜객체).메서드()
   - 역할: 감시자 역할입니다. "이 가짜 객체의 메서드가 실제로 호출되었니?" 라고 확인합니다.
   - 이유: Service 코드가 Repository.save()를 빼먹지 않고 실행했는지 검사하기 위함입니다.


================================================================================
4. Controller 테스트 (MockMvc - 웹 요청 흉내)
   : 브라우저 없이 API 요청을 날리고 응답을 검사하는 함수들
================================================================================

1) @WebMvcTest(컨트롤러.class)
   - 역할: 웹 계층(Controller) 관련 빈만 로드합니다. Service, Repository는 로드 안 함.
   - 이유: API 주소 매핑, 파라미터 수신, JSON 반환 등 껍데기만 빠르게 테스트하기 위함입니다.

2) @MockitoBean (구 @MockBean)
   - 역할: 스프링 컨테이너에 있는 빈을 가짜(Mock)로 바꿔치기해서 등록합니다.
   - 이유: Controller는 Service를 의존하는데, Service 로직까지 돌리면 복잡하니까 가짜 Service를 꽂습니다.

3) mockMvc.perform(요청)
   - 역할: 실제로 브라우저에서 URL을 치는 것처럼 요청을 수행합니다.
   - 예: mockMvc.perform(post("/api/users")) -> POST 요청 전송

4) .contentType(MediaType.APPLICATION_JSON)
   - 역할: "나 지금 JSON 데이터 보낼 거야"라고 헤더에 명시합니다.
   - 이유: 이게 없으면 서버가 데이터를 못 알아들을 수 있습니다.

5) .content(문자열)
   - 역할: 요청 Body(본문)에 데이터를 실어 보냅니다.

6) objectMapper.writeValueAsString(객체)
   - 역할: 자바 객체(new Dto(...))를 JSON 문자열("{"name":"..."}")로 변환해줍니다.
   - 이유: 웹 통신은 문자열(JSON)로 해야 하니까요.

7) .andExpect(...)
   - 역할: 응답 결과를 검증합니다.
     > .status().isOk(): 200 OK가 왔나?
     > .status().isCreated(): 201 Created가 왔나? (생성 성공 시)
     > .jsonPath("$.email").value("..."): JSON 응답 안에 email 필드 값이 내가 원한 값인가?