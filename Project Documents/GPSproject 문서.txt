====================================================
[프로젝트 최종 아키텍처] GPS 기반 러닝 분석 앱
====================================================

1. 프로젝트 목표
----------------------------------------------------
- 모바일 앱(React Native)에서 사용자의 러닝을 시작하면, GPS 좌표/속도/시간을 실시간으로 서버에 전송.
- 서버는 이 데이터를 받아 실시간 거리/평균 속도를 계산하여 앱에 다시 보여줌.
- 러닝 종료 시, 전체 경로와 데이터를 영구 저장하고 분석 리포트를 제공.
- 대규모 사용자가 동시에 뛰어도 1초의 지연이나 데이터 유실 없이 안정적으로 운영.

2. 전체 기술 스택 (All-in-One)
----------------------------------------------------
- 클라이언트: React Native
- 백엔드: Spring Boot, AWS Lambda
- 데이터베이스: MySQL (on RDS), Redis (on ElastiCache)
- 데이터 파이프라인: Kafka (on MSK)
- 인프라/운영: AWS, Docker, Kubernetes (on EKS), Terraform
- 자동화/모니터링: GitHub Actions (CI/CD), Prometheus/Grafana

3. [핵심] 데이터 흐름 및 기술 연동 시나리오
----------------------------------------------------
1. (앱) 사용자가 '러닝 시작'을 누른다.
2. (앱) React Native가 2초마다 GPS 좌표(위도, 경도, 시간)를 API로 쏜다.
3. (백엔드) 이 요청은 K8s 위의 Spring Boot API를 거치지 않고, 대용량 처리에 특화된 **Kafka(카프카)**로 바로 전송된다. (이것이 핵심)
4. (데이터 처리)
    a. **Redis(레디스)**가 '현재 뛰는 중인 유저'의 실시간 누적 거리/시간을 1초마다 갱신. (실시간 현황판)
    b. **AWS Lambda(서버리스)**가 Kafka에 쌓인 데이터를 비동기적으로 읽어, 최종 분석 데이터를 **MySQL(RDS)**에 영구 저장. (러닝 종료 후 처리)
5. (앱) 사용자가 앱에서 '내 실시간 속도'를 볼 때: **Redis**에서 데이터를 1초 만에 가져와 보여준다.
6. (앱) 사용자가 '지난주 러닝 기록'을 볼 때: **MySQL(RDS)**에서 데이터를 가져와 보여준다. (이때도 Redis 캐시를 사용)

4. 프로젝트별 기술 상세 역할 (총정리)
----------------------------------------------------

### [ 1. 인프라 구축: 땅과 설계도 ]

- **AWS (Amazon Web Services)**
  - 역할: 모든 서비스가 올라갈 '땅'과 '건물'.
  - 프로젝트 적용:
    - EKS (Kubernetes), RDS (MySQL), ElastiCache (Redis), MSK (Kafka) 등 모든 인프라를 빌려 쓰는 플랫폼.

- **Terraform (IaC - Infrastructure as Code)**
  - 역할: AWS 인프라를 마우스 클릭이 아닌 '코드로 된 설계도'로 관리.
  - 프로젝트 적용:
    - "EKS 클러스터 1개, RDS M-size 1개, Redis M-size 1개" 등이 정의된 `main.tf` 파일 하나만 실행하면, 10분 만에 모든 인프라가 자동으로 생성됨. (실수 방지 및 자동화)

### [ 2. 실시간 데이터 고속도로 ]

- **Kafka (카프카 / AWS MSK)**
  - 역할: 실시간 'GPS 데이터 고속도로'.
  - 프로젝트 적용:
    - 수만 명이 동시에 달려도 2초마다 쏘는 GPS 데이터를 **단 하나도 유실 없이** 순서대로 받아내는 중앙 파이프라인. 서버가 잠시 죽어도 Kafka가 데이터를 안전하게 보관함.

### [ 3. 애플리케이션 공장 및 지휘자 ]

- **Docker (도커)**
  - 역할: Spring Boot 서버를 포장하는 '밀키트'.
  - 프로젝트 적용:
    - Spring Boot 애플리케이션을 OS, Java 25 등 모든 환경과 함께 `Dockerfile`로 정의하여 '컨테이너 이미지'로 만듦. (어디서든 동일하게 실행 보장)

- **Kubernetes (쿠버네티스 / AWS EKS)**
  - 역할: 도커(밀키트)를 자동으로 관리하는 '총괄 매니저'.
  - 프로젝트 적용:
    - Spring Boot 컨테이너를 EKS 위에 배포.
    - 저녁에 러닝 사용자가 몰리면 Spring Boot 컨테이너를 자동으로 3개에서 10개로 늘림(오토 스케일링).
    - 특정 서버가 죽으면 컨테이너를 즉시 다른 곳에서 다시 살려냄(장애 복구).

### [ 4. 핵심 두뇌: 서비스와 데이터 처리 ]

- **Spring Boot (백엔드)**
  - 역할: 앱의 '메인 두뇌'. (K8s 위에서 실행)
  - 프로젝트 적용:
    - 회원가입, 로그인, 친구 관리, '내 과거 러닝 기록 조회' 등 **동기식 API**를 제공.
    - (참고: 실시간 GPS 데이터는 Kafka가 처리하도록 역할을 넘김)

- **AWS Lambda (서버리스)**
  - 역할: 필요할 때만 일하는 '비동기 처리 알바생'.
  - 프로젝트 적용:
    - Kafka에 쌓인 'A유저 러닝 종료' 이벤트를 감지.
    - Lambda가 실행되어 30분간의 GPS 데이터를 모두 읽어 '최고 속도', '경로 지도 이미지' 등을 계산한 뒤, 최종 결과본을 **MySQL(RDS)**에 저장. (서버 관리 필요 없음)

- **Redis (레디스 / AWS ElastiCache)**
  - 역할: '실시간 현황판' + '1초 응답용 캐시 서랍'. (메모리 기반)
  - 프로젝트 적용:
    - 1. **(실시간 집계)** "A유저가 현재 4.5km 뛰는 중"처럼, 현재 러닝 중인 유저의 실시간 누적 거리를 1초마다 업데이트하고 저장. (DB보다 100배 빠름)
    - 2. **(세션 관리)** K8s 환경에서 사용자가 로그인했을 때, 그 정보를 Redis에 저장하여 어떤 서버로 접속해도 로그인이 풀리지 않게 함.
    - 3. **(캐시)** MySQL에서 읽어온 '어제 러닝 기록'을 Redis에 임시 저장하여, 다음 조회 시 DB까지 가지 않고 0.1초 만에 응답.

- **MySQL (RDBMS / AWS RDS)**
  - 역할: '원본 데이터를 영구 보관하는 은행 금고'. (디스크 기반)
  - 프로젝트 적용:
    - 사용자 회원 정보 (ID, PW).
    - 러닝이 최종 종료된 후의 **모든 분석 데이터 원본** (경로, 총 거리, 평균 속도, 소모 칼로리 등)을 안전하게 영구 저장.

### [ 5. 자동화 및 관제 센터 ]

- **CI/CD (GitHub Actions 등)**
  - 역할: '개발-배포 자동화 파이프라인'.
  - 프로젝트 적용:
    - 개발자가 Spring Boot 코드를 수정하고 GitHub에 푸시(Push)하면,
    - 1. (CI) 자동으로 테스트 및 Docker 이미지 빌드.
    - 2. (CD) 성공 시, 자동으로 Kubernetes(EKS)에 새로운 버전의 앱을 배포.

- **Observability (Prometheus / Grafana)**
  - 역할: '통합 모니터링 대시보드'.
  - 프로젝트 적용:
    - "현재 뛰고 있는 유저 수", "Kafka에 데이터가 밀려있는지?", "K8s의 서버 점유율" 등 모든 시스템 현황을 Grafana 대시보드에서 실시간으로 확인. (문제 발생 시 즉시 알림)