====================================================
[프로젝트 최종 아키텍처 - NAS Ver.] GPS 기반 러닝 분석 앱
====================================================

1. 프로젝트 목표 (NAS 환경 최적화)
----------------------------------------------------
- 개인 NAS 서버(Home Lab)를 활용하여 비용 효율적인 러닝 분석 시스템 구축.
- 모바일 앱(React Native)에서 GPS 데이터를 NAS 서버로 전송하여 실시간 처리.
- 클라우드 의존 없이 데이터 주권 확보 및 온프레미스(On-Premise) 운영 경험 축적.
- Docker 기반의 컨테이너 격리 환경을 통해 안정적인 서비스 운영.

2. 해결하고자 하는 문제
----------------------------------------------------
- 필요한 운동이 무엇인지 인지하지 못한체 주어진 운동으로 발전을 하려고 함

3. 전체 기술 스택 (NAS All-in-One)
----------------------------------------------------
- 하드웨어: 개인 NAS (유그린) + RAM
- 클라이언트: React Native
- 백엔드(API): Spring Boot (API 서버)
- 백엔드(Worker): Spring Boot
- 데이터베이스: MySQL (Docker Container), Redis (Docker Container)
- 데이터 파이프라인: Kafka (Docker Container + KRaft/Zookeeper)
- 인프라/운영: Docker, Docker Compose, Portainer (컨테이너 관리 GUI)
- 자동화/모니터링: GitHub Actions (CI), Watchtower (CD), Prometheus/Grafana

4. [핵심] 데이터 흐름 및 기술 연동 시나리오
----------------------------------------------------
1. (앱) 사용자가 '러닝 시작'을 누른다.
2. (앱) React Native가 [초]초마다 GPS 좌표(위도, 경도, 시간)를 NAS의 외부 접속 URL(DDNS)로 쏜다.
3. (API 서버) NAS 내의 Spring Boot API 컨테이너가 요청을 받아 Kafka 컨테이너로 전송한다.
   (NAS 환경에서는 외부에서 Kafka로 직접 붙기보다 API 게이트웨이 역할을 하는 Spring Boot를 거치는 것이 보안/네트워크 설정상 유리함)
4. (데이터 처리)
    a. Spring Worker 컨테이너 (Lambda 대체)가 Kafka를 구독하고 있다가 데이터를 가져감.
    b. Redis 컨테이너에 '현재 뛰는 중인 유저'의 실시간 누적 거리/시간을 갱신.
    c. 러닝 종료 시, Worker가 최종 데이터를 분석하여 MySQL 컨테이너에 영구 저장.
5. (앱) 실시간 속도 조회: API 서버를 통해 Redis 데이터를 가져옴.
6. (앱) 지난 기록 조회: API 서버를 통해 MySQL 데이터를 가져옴.

5. 프로젝트별 기술 상세 역할 (NAS 버전 수정됨)
----------------------------------------------------

[ 1. 인프라 구축 ]

- NAS (Network Attached Storage)
  - 역할: AWS 전체를 대체하는 물리적인 서버(본체).
  - 프로젝트 적용:
    - 24시간 켜져 있는 리눅스 기반 서버로, 모든 도커 컨테이너가 이 위에서 실행됨.
    - 외부(LTE/5G)에서 접속 가능하도록 포트 포워딩 및 DDNS 설정 필수.

- Docker Compose (IaC 대체)
  - 역할: Terraform과 Kubernetes를 대신하는 '설계도'.
  - 프로젝트 적용:
    - `docker-compose.yml` 파일 하나에 MySQL, Redis, Kafka, Spring Boot API, Worker 등 모든 컨테이너의 설정(포트, 볼륨, 네트워크)을 정의.
    - `docker-compose up -d` 명령어 한 번으로 전체 서비스 실행.

[ 2. 실시간 데이터 파이프라인 ]

- Kafka (Docker Container)
  - 역할: AWS MSK를 대체하는 '자가 설치형 카프카'.
  - 프로젝트 적용:
    - NAS 리소스를 고려하여 단일 브로커(Single Broker) 모드로 가볍게 구성.
    - API 서버와 Worker 사이에서 데이터를 완충해주는 큐(Queue) 역할 수행.

[ 3. 애플리케이션 공장 및 관리 ]

- Docker (도커)
  - 역할: 서비스 실행의 기본 단위.
  - 프로젝트 적용:
    - NAS의 OS(DSM 등)에 구애받지 않고 리눅스 환경과 동일하게 DB와 백엔드 실행.

- Portainer (선택 사항)
  - 역할: NAS에서 도커 컨테이너를 쉽게 관리하는 '웹 관리자 화면'.
  - 프로젝트 적용:
    - 로그 확인, 컨테이너 재시작, 리소스 점유율 확인 등을 명령어가 아닌 GUI로 클릭해서 관리.

[ 4. 핵심 두뇌: 서비스와 데이터 처리 ]

- Spring Boot (API Container)
  - 역할: 앱과 통신하는 메인 서버.
  - 프로젝트 적용:
    - 사용자 요청(로그인, 기록 조회, GPS 수신)을 처리하는 최전방 서버.

- Spring Boot 
  - 역할: AWS Lambda를 대체.
  - 프로젝트 적용:
    - Lambda처럼 필요할 때만 켜지는 것이 아니라, 백그라운드 프로세스로 계속 실행됨.
    - Kafka에 새 데이터가 들어오면 즉시 가져와서 거리 계산, 경로 분석, DB 저장 등의 무거운 작업을 수행. (API 서버의 부하를 줄여줌)

- Redis (Docker Container)
  - 역할: AWS ElastiCache 대체.
  - 프로젝트 적용:
    - `redis:alpine` 이미지 등을 사용하여 가볍게 띄움.
    - 실시간 러닝 현황 및 세션 정보를 메모리에 저장.

- MySQL (Docker Container)
  - 역할: AWS RDS 대체.
  - 프로젝트 적용:
    - NAS의 하드디스크 폴더를 도커 볼륨(Volume)으로 연결하여, 컨테이너를 삭제해도 데이터가 날아가지 않게 설정(마운트)하는 것이 핵심.

[ 5. 자동화 및 관제 ]

- GitHub Actions + Watchtower (CI/CD)
  - 역할: 배포 자동화.
  - 프로젝트 적용:
    - 1. (CI) GitHub Actions에서 코드를 빌드하고 Docker Hub(비공개 저장소)에 이미지를 올림.
    - 2. (CD) NAS에 설치된 Watchtower 컨테이너가 주기적으로 Docker Hub를 감시하다가, 새 이미지가 있으면 자동으로 기존 컨테이너를 끄고 새 버전으로 교체함.

- Prometheus / Grafana (Docker Container)
  - 역할: NAS 성능 및 서버 모니터링.
  - 프로젝트 적용:
    - NAS의 CPU/RAM 사용량과 컨테이너별 리소스 사용량을 시각화하여 "NAS가 뻗지 않는지" 감시.