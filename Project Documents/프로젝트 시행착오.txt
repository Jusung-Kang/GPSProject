frontend 파일생성
    - npx @react-native-community/cli init frontend

Gradl
    - .\gradlew.bat --stop
	
Java Version
    - 처음에 25버전 -> 21버전 -> 17버전으로 내려옴 이유는 react-native 에서 호환이 되는 버전이
	  17버전이라고 함.
	  
frontend 실행
    - npx react-native run-android

Docker 중지
    - docker stop mysql-db
	- 중지 체크 -> docker ps
	
backend 파일에 Dockerfile 추가. 
	FROM openjdk:17-jdk-slim
	WORKDIR /app
	EXPOSE 8080
	ENTRYPOINT ["java", "-jar", "app.jar"]

backend 파일에 Dockerfile을 추가한 후
    cd backend 
	.\gradlew build -x test
	ㄴ gradlew build를 하는데 test를 빼고 실행. 
	ㄴ test를 빼고 하는 이유는 mysql을 사용하지않고 H2를 사용하기때문
	ㄴ test 할경우에 만약 db에 연결이 안되어 있다면 main application.properties를 찾아감.
	

git
	
# 1. 모든 변경 사항을 장바구니에 담고
git add .
ㄴ 상태확인 -> git status

# 2. 메시지를 붙여서 로컬에 저장하고
git commit -m "로그인 기능 추가"

# 3. GitHub에 업로드한다.
git push origin main

# 4. 바뀐것 보는 방법
git show
ㄴ 체크 후에는 q 를 눌러 나올수 있다. 


Docker Compose 실행 문제 해결 요약
===================================

1. Docker Desktop 잔여 프로세스 문제
-----------------------------------
* 문제: Docker Desktop 시작 시, 이전 프로세스가 남아 시작을 방해함 ('Lingering processes detected').
* 해결: 'Stop processes' 버튼 클릭 (또는 작업 관리자/재부팅).


2. Kafka-Zookeeper 연결 경쟁 상태 (Race Condition)
--------------------------------------------------
* 문제: 'docker-compose up' 시 Kafka가 Zookeeper 연결에 실패 ('Connection refused' 또는 'Timed out'). Spring Boot 앱도 시작 지연됨.
* 원인: 'depends_on' 설정이 서비스 준비 완료까지 기다려주지 않음.
* 해결: 
    - Zookeeper와 Kafka 서비스에 'healthcheck' 설정 추가.
    - Kafka와 Spring Boot 앱의 'depends_on'에 'condition: service_healthy' 추가하여 서비스 준비 완료까지 대기하도록 수정.


3. Healthcheck 설정 오류 및 수정
---------------------------------
* 문제: Healthcheck 추가 후에도 Zookeeper, Kafka가 '(unhealthy)' 상태로 표시됨.
* 원인:
    - Zookeeper: 사용된 이미지에서 'ruok', 'stat' 명령어가 healthcheck용으로 기본 활성화되지 않음. 환경 변수 설정도 적용되지 않음.
    - Kafka: 'cub kafka ready' 명령어의 기본 대기 시간이 부족하거나, 명령어가 이미지 내에 없을 가능성.
* 해결 (최종):
    - Zookeeper Healthcheck: 단순 포트 확인 ('nc -z localhost 2181') 방식으로 변경. 'start_period' 추가 (15초).
    - Kafka Healthcheck: Kafka 기본 도구 ('kafka-topics.sh --list') 사용으로 변경. 'start_period' 추가 (30초).


4. Healthcheck 로그 오해
-------------------------
* 문제: Zookeeper 로그에 'EndOfStreamException'이 계속 출력되어 사용자가 오류로 오인함.
* 원인 설명: 주기적인 healthcheck 실행 시 연결 후 바로 종료하기 때문에 발생하는 정상 로그임. 서비스가 '(healthy)' 상태면 무시해도 됨.


결과
----
최종 수정된 'docker-compose.yml' 파일을 통해, 컴퓨터 재부팅 후에도 'docker-compose up' 명령만으로 모든 서비스가 안정적으로 순차 실행되도록 함.

Docker Desktop.exe 가 실행중인지 확인하는 방
tasklist | findstr /i "Docker Desktop.exe"

만약 실행중이라면 Docker Desktop 좌하단에 있는 ... 의 
Quit Docker Desktop 클릭하기

만약 실행중이라면 강제로 끄는 방법
taskkill /IM "Docker Desktop.exe" /F

2025/11/09
docker를 노트북에서 PC로 옮기면서 자바를 읽어들이지 못하고 있어 backend에 있는 Dockerfile에 FROM을 수정하고 있다. 
{
  "builder": {
    "gc": {
      "defaultKeepStorage": "20GB",
      "enabled": true
    }
  },
  "experimental": false
}
-다운받은 java 버전을 전부 입력하니 java는 넘어갔음. 
 ㄴFROM eclipse-temurin:17-jdk
-빌드를 하려했는데 오류가 나와 보니 테스트 까지 포함하고 빌드하려 하여 .\gradlew build -x test 실행함
-docker-compose up 을 하는데 제대로 작동이 되지 않아 보니 spring에 대소문자가 바껴있는것 확인.
 ㄴ .\gradlew build -x test 후 docker-compose up --build 하니 정상작동함.


2025/11/11 
Postman을 사용하여 Users를 Get 하려고 했지만 이미 들어가 있는 값이 나오지 않았다. 알고보니 Spring에서 소문자로 된 테이블을 만들고 자동으로 그 테이블을 바라보고 있었음.
ㄴ 보통 소문자를 사용한다고 함. 
그래서 대문자로 된 테이블을 drop 하고 소문자로 된 테이블에 값을 넣고 Postman 돌려보니 값이 잘 나온다.

오늘 한것
- findAll Api Design
  ㄴ @GetMapping("api/users")
      ㄴ findAll 함수를 사용하여 user_m 테이블에 있는 유저 모두 불러오도록 하였음.
	  

2025/11/13
ㄴ 아직 client <-> controller <-> service <-> repository <-> db
   의 계념이 머리속에서 정리가 잘 안된다. 책을 보고 따라하지만말고, AI를 보고 따라 만들지만 말고 정확하게 어떻게 돌아가는지 흐름을 파악하고 만들면 도움이 많이 될것 같다. 
   코드를 짤때 미리 해당 플로우를 그림으로 그린다음 실행하는것도 괜찮은 방법인것 같다. 
ㄴ 오늘의 API Design은  AvailableSports 의 save, findAll, findById 이 3가지를 구현하였다.
ㄴ 명칭을 조금더 깔끔하게 정리할수있으면 좋을것 같다.

2025/11/14
ㄴ dto, service, domain 부분을 완전 다 바꾸게 되었다. dto는 데이터를 전달하는 깡통이 되어야 하는데 toEntity와 같이 builder를 하고 있었다. 이 부분을 service 쪽에서 json을 entity로 가공하여 db로 보낼수 있도록 수정하였다.
ㄴ AI를 사용해서 Controller 부분 수정을 하였으나 완벅하게 이해가 가지는 않는상황이다. 

2025/11/15
ㄴ 코드를 조금더 세션별로 나눠서 구분지었음. UserMAPI 에 AvailableSports가 생성, 업데이트가 되어있어 이걸 AvailableSportsApi를 생성하여 배치하였음.
ㄴ JPA와 DB의 테이블, 컬럼명이 서로 바로보고 있지않아 snake로 통일시켜 Spring에 @Column을 지워버렸음.

2025/11/16
ㄴ SportType 쪽 service, controller, dto 코드 구현했음.
ㄴ controller 부분에서 정확하게 어디서 dto를 사용해서 값을 불러오도록 해야하는지, 어디서 entity를 사용해서 값을 불러와야하는지, list를 사용해서 값을 어떻게 가져오는지 조금더 공부하고 직접 구현해봐야 할것같음.
ㄴ 아직 정확하게 데이터가 들어가는지 테스트는 해보지 않았음. postman을 사용해서 값 넣어보면 좋을것 같다
ㄴ 2025/11/18에는 TDD 작성하기.

2025/11/17
ㄴ tdd파일을 ai를 이용해서 짜긴 했으나 아직 이해가 안가 공부를 해야함. UserM 은 Ai를 사용해서 했으나 다른부분은 공부해서 스스로 코드를 짜보면 도움이 많이 될것 같음

2025/11/18
ㄴ AvailableSports Repository쪽 tdd 구현하는 중. pk가 나와 어떻게 할지 몰라 Ai 사용하였으며 .userM(userM), .SportType(sportType)을 왜 사용해야 하는지 이해하였음.

2025/11/22
ㄴ AvailableSports Service쪽 tdd 구현하였음. 조금더 공부하여 나머지 tdd 작성하여 내것으로 만들면 좋을것 같음.
ㄴ Repository에 문제있으니 체크해야함. -> mapid를 수정하여 수정된 id명을 바꿔주니 정상작동하였음
ㄴ 2025/11/23 ApiController tdd 작성 하야함

2025/11/24
ㄴ AvailableSports, SportType, UserM tdd 작성 완료 하였음.
ㄴ Exercise History Service, Api Controller 만들고 있는중. Many to one 이 엮겨있어 한번더 정확히 집고 넘어가면 좋을듯 함

2025/11/25
ㄴ Controller -> Service SaveRequestDto, Service -> Controller ResponseDto 이렇게 값을 들고올수 있도록. 즉 바로 repository를 return 하지 않도록 수정하기.
ㄴ UserM은 Dto로 데이터를 보내는것으로 수정해두었으니 참고하여 바꾸면 될것같다. 
ㄴ n+1 문제 더 확실하게 경험해보기. 말로만 듣지말고 직접 그 문제를 직면하면 더 잘 이해를 할것같으니 일부러 n+1 문제를 내보는것도 괜찮다고 생각한다.

2025/11/29
ㄴ service tdd 작성중인데 아직 정확하게 이해를 못하고 구현하는것 같음. 조금더 기초를 공부하고 ai 사용을 최소화 하고 문제를 해결해보려 해야할것같음. 
ㄴ exercisehistory service tdd 공부 다시하기, controller tdd 작성하기

2025/11/30
ㄴ gps repository, service, controller 작성 하였음. tdd 작성하면 됌
ㄴ 전체적으로 데이터 넣으면서 테스트 해보고 설계 한번 다시 생각 하고 넘어가야할것같음.
ㄴ tdd의 개념을 더 확실하게 잡고 가야 할것같음. 
ㄴ gpsdatarepository 에 작성한 findallbyexercisehistory_historyid <- exercisehistory 도메인에 있는 해당 클래스 이름과 id값을 마지막에 넣어주어야 JPA에서 알아서 쿼리 작성을 함.